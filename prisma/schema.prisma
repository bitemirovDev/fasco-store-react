generator client {
  provider = "prisma-client-js"
}

// куда подключаемся
datasource db {
  provider = "postgresql"
  url      = env("POSTGRES_URL") // uses connection pooling
  // directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

model User {
  id       Int             @id @default(autoincrement())
  fullName String
  email    String          @unique
  password String
  cart     Cart?
  // orders   Order[]
  review   ProductReview[]

  sessions Session[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Session {
  id        String   @id
  userId    Int
  expiresAt DateTime

  user User @relation(references: [id], fields: [userId], onDelete: Cascade)
}

model CustomerReview {
  id         Int    @id @default(autoincrement())
  name       String
  avatar     String
  review     String
  rating     Float
  profession String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductCategory {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[] @relation("ProductCategories")
}

model ProductDiscount {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  percent  Int
  products Product[]

  endDate DateTime @default("2025-03-15T23:59:59Z")
}

model ProductCollection {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[] @relation("ProductCollections")
}

model Product {
  id          Int                 @id @default(autoincrement())
  img         Json
  name        String
  price       Float
  rating      Float               @default(0.00)
  stock       Int                 @default(0)
  collections ProductCollection[] @relation("ProductCollections")
  categories  ProductCategory[]   @relation("ProductCategories")
  sizes       ProductSize[]
  brand       ProductBrand        @relation(fields: [brandId], references: [id])
  brandId     Int
  discount    ProductDiscount?    @relation(fields: [discountId], references: [id])
  discountId  Int?
  reviews     ProductReview[]
  cartItems   CartItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductReview {
  id        Int     @id @default(autoincrement())
  product   Product @relation(fields: [productId], references: [id])
  productId Int
  user      User    @relation(fields: [userId], references: [id])
  userId    Int
  review    String?
  rating    Float   @default(0.00)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ProductBrand {
  id       Int       @id @default(autoincrement())
  name     String    @unique
  products Product[]
}

model ProductSize {
  id        Int     @id @default(autoincrement())
  product   Product @relation(fields: [productId], references: [id])
  productId Int
  name      String // Например, "S", "M", "L", "XL"
  quantity  Int     @default(0) // Сколько единиц этого размера в наличии

  cartItems CartItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([productId, name]) // Запрещает дублировать размеры для одного продукта
}

model Cart {
  id          Int        @id @default(autoincrement())
  user        User?      @relation(fields: [userId], references: [id])
  totalAmount Float      @default(0.00)
  token       String
  cartItems   CartItem[]

  userId Int? @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CartItem {
  id       Int    @id @default(autoincrement())
  quantity Int
  price    Float
  title    String
  img      String

  productId Int
  sizeId    Int? // Может быть null, если у товара нет размеров (например, аксессуары)
  cartId    Int

  cart    Cart         @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product      @relation(fields: [productId], references: [id], onDelete: Cascade)
  size    ProductSize? @relation(fields: [sizeId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([cartId, productId, sizeId]) // Один товар одного размера в корзине не должен дублироваться
}

// model Order {
//   id          Int         @id @default(autoincrement())
//   user        User?       @relation(fields: [userId], references: [id])
//   userId      Int
//   totalAmount Float
//   status      OrderStatus
//   paymentId   String?

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt
// }

// enum OrderStatus {
//   PENDING
//   COMPLETED
//   CANCELLED
// }
